\documentclass[ ../main.tex]{subfiles}
\providecommand{\mainx}{..}
\begin{document}
\section{Perfect Hash Map}

The Perfec Hash Map (PHM) is a data structure that models the concept of a function
$X \mapsto Y$ where $X$ abd $Y$ are countable (finite or infinte). 


Suppose we have a map $f : X \mapsto Y$ that is *laten  t* or otherwise not known
explicitly. We can approximate $f$ with a PHM $\hat{f}$ that is a function
$\hat{f} : X \mapsto Y$ such that $\hat{f}(x) = f(x)$ for all $x \in A \subseteq X$,
and for $x \notin A$, it does not equal $f(x)$ with some probability that depends
on $X \mapsto Y$. In the "best-case" scenario, the probability
$$
\Pr\{\hat{f}(x) = f(x) \mid x \notin A\} = \frac{1}{|A|},
$$
where $|A|$ is the size of the set $A$, but it can be anything between $0$ and $1/|A|$.

The PHM is designed to be *fast* and reasonably space efficient, since it is
based on a perfect hash function. In general, it should only be used if the
error rate on $X \setminus A$ is unimportant or there is no prior knowledge
about what the values of $f$ are on $X \setminus A$.

If there is prior knowledge about the values of $f$ on $X \setminus A$, and
the error rate is important, then a different data structure should be used,
like the Entropy Map. The Entropy Map tends to be overall a better performer,
but there are special cases in which the PHM is more efficient, e.g,, when
the function $f$ is a bijection over its restricted domain $A$ and we do
do not care (or have any prior information) about the values of $f$ on
$X \setminus A$.


- Over some subset of $X$, the 

A PHM that approximates a map with $m$ keys, a mean bit length per value $\mu$, false positive rate $\fprate$, and load factor $r$ is denoted by
\begin{equation}
    \mathrm{phm}(m, \mu, \fprate, r)\,.
\end{equation}
The **minimal** PHM has load factor $r=1$ and may be denoted by $\pmapf(m,\mu,\fprate)$.
\end{definition}

%\begin{algorithm}[h]
%    \caption{Theoretical implementation of \protect\MakeApproxMap}
%    \label{alg:shmap}
%    \SetKwProg{func}{function}{}{}
%    \KwIn
%    {
%        $\Mt \in \cisb \times \cisb$ is the **finite map** $\{(k_1,v_1),\ldots,(k_m,v_m)\}$ to approximate and $\fprate$ is the **\gls{gls-fprate**}.
%    }
%    \KwOut
%    {
%        A PHM $\Mt^* \supset \Mt$ with a \gls{gls-fprate} $\fprate$.
%    }
%    \func{\MakeApproxMap{$\Mt$, $\fprate$}}
%    {
%        \tcp{Make a minimal perfect hash function for the keys.}
%        $\Set{K} \gets \left\{k \colon (k,v) \in \Mt\right\}$\;
%        $\ph_\Set{K} \colon \cisb \mapsto \Set{Z}^+ \gets$ \MakeMinimalPerfectHash{$\Set{K}$}\;        
%        
%        $k \gets \left\lceil \log_2 \frac{1}{\fprate} \right\rceil$\;
%        $\matrx{V} \gets m$-by-$k$ bit matrix\;
%        \For{$j \gets 1$ \KwTo $m$}
%        {
%            $\matrx{V}\!\left[\ph_\Set{K}(x_j)\right] \gets \hash(k_j) \mod k$\;
%        }
%        \For{$n \gets 0$ \KwTo $\infty$}
%        {
%            $\found \gets \True$\;
%            \For{$j \gets 1$ \KwTo $2^n$}
%            {
%                $b_n \gets$ draw random bit string from $\cisb_n$ without replacement\;
%                \For{$i \gets 1$ \KwTo $m$}
%                {
%                    \tcp{The value $v_j$ is **self-delimiting code** so we
%                    check that the first $\BL(v_j)$ bits of the hash is equal to $v_j$.}
%                    \If{$\hash(k_j \catop b_n) \mod \BL(v_j^*) \neq v_j^*$}
%                    {
%                        \label{line:selfterm}
%                        $\found \gets \False$\;
%                        \Break\;
%                    }
%                }
%                \If{\notfn \found}
%                {
%                    \Break\;
%                }
%            }
%            \If{\found}
%            {
%                \tcp{This tuple codes the PHM.}
%                \Return $(\matrx{V},b_n)$\;
%            }
%        }
%    }
%\end{algorithm}


\subsection{Lower-bound on space complexity}



\subsection{Upper-bound on entropy}



\end{document}